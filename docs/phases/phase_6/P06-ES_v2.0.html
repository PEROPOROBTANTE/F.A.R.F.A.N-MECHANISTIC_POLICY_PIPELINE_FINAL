<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F.A.R.F.A.N. | Fase 6: Agregación por Clúster</title>
    <style>
        :root {
            --atroz-red-500: #C41E3A; --atroz-blue-electric: #00D4FF; --atroz-green-toxic: #39FF14;
            --atroz-copper-500: #B2642E; --atroz-copper-oxide: #17A589; --atroz-ink: #E5E7EB; --atroz-bg: #0A0A0A;
            --font-main: 'JetBrains Mono', monospace;
        }
        @font-face {
            font-family: 'JetBrains Mono';
            src: url('https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2') format('woff2');
            font-weight: 400; font-style: normal;
        }
        body { background-color: var(--atroz-bg); color: var(--atroz-ink); font-family: var(--font-main); margin: 0; padding: 0; font-size: 14px; line-height: 1.8; }
        .container { max-width: 960px; margin: 0 auto; padding: 40px; }
        h1, h2, h3 { font-weight: 400; letter-spacing: 2px; text-transform: uppercase; }
        h1 { font-size: 28px; color: var(--atroz-green-toxic); border-bottom: 1px solid var(--atroz-copper-500); padding-bottom: 15px; margin-bottom: 30px; }
        h2 { font-size: 18px; color: var(--atroz-copper-oxide); margin-top: 50px; border-left: 3px solid var(--atroz-copper-oxide); padding-left: 10px; }
        h3 { font-size: 16px; color: var(--atroz-copper-500); margin-top: 30px; }
        p, li { text-align: justify; text-shadow: 0 0 2px rgba(229, 231, 235, 0.1); }
        ul, ol { padding-left: 20px; }
        li { margin-bottom: 10px; }
        code { background-color: #1a1a1a; padding: 3px 6px; border-radius: 4px; font-size: 12px; color: var(--atroz-blue-electric); }
        .diagram-container { margin: 50px 0; padding: 30px; background: radial-gradient(circle, rgba(57, 255, 20, 0.1) 0%, transparent 70%); border: 1px solid var(--atroz-green-toxic); border-radius: 8px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Fase 6: Síntesis Estratégica mediante Agregación por Clúster</h1>

        <h2>1. Propósito</h2>
        <p>
            La Fase 6 representa el penúltimo y más alto nivel de síntesis temática dentro de la jerarquía de agregación. Su función es consolidar los 10 objetos discretos <code>AreaScore</code> en un conjunto más pequeño de "clústeres" estratégicos. Estos clústeres, definidos dentro del monolito, representan dominios estratégicos amplios y transversales (ej., "Derechos Humanos", "Gobernanza", "Desarrollo Sostenible"). Esta fase síncrona abstrae el análisis a su nivel más alto posible antes de la evaluación macro final, produciendo un puñado de objetos <code>ClusterScore</code> que proporcionan una visión general concisa y estratégica del rendimiento del documento de política a través de sus pilares centrales.
        </p>

        <h2>2. Definiciones Clave</h2>
        <ul>
            <li><strong>Clúster:</strong> Una agrupación estratégica de varias Áreas de Política según se define en el bloque <code>niveles_abstraccion</code> del monolito. Un clúster representa un pilar temático principal del marco de políticas.</li>
            <li><strong>Agregación por Clúster:</strong> El proceso de agrupar los objetos <code>AreaScore</code> de acuerdo con las definiciones de clúster del monolito y calcular una puntuación única y unificada para cada clúster.</li>
            <li><strong>ClusterAggregator:</strong> La clase especializada de <code>aggregation.py</code> que contiene la lógica para este último nivel de agregación. Es responsable de mapear las áreas a los clústeres y aplicar el algoritmo de consolidación apropiado.</li>
            <li><strong>ClusterScore:</strong> El artefacto de salida para cada clúster estratégico. Contiene la puntuación agregada final para el clúster y mantiene una trazabilidad completa al vincularse a sus objetos <code>AreaScore</code> constituyentes.</li>
        </ul>

        <h2>3. Flujo Operacional Detallado</h2>
        <p>
            El método <code>Orchestrator._aggregate_clusters()</code> ejecuta esta fase de manera síncrona, ya que el número de operaciones es pequeño y las dependencias de datos son directas.
        </p>
        <ol>
            <li><strong>Enriquecimiento de Mapeo de Clúster:</strong> El primer paso es enriquecer los 10 objetos <code>AreaScore</code> de entrada con su <code>cluster_id</code> correspondiente. El sistema construye un mapa de área a clúster analizando las definiciones de clúster en el monolito. Luego, itera a través de los objetos <code>AreaScore</code>, adjuntando el <code>cluster_id</code> correcto a cada uno. Las áreas no mapeadas a ningún clúster se registran como una advertencia y se filtran.</li>
            <li><strong>Agrupación de Entradas:</strong> La lista enriquecida de objetos <code>AreaScore</code> se agrupa en un mapa hash, utilizando el <code>cluster_id</code> recién adjuntado como clave. Esto particiona las 10 puntuaciones de área en un pequeño número de grupos (típicamente 3-5), uno por cada clúster definido.</li>
            <li><strong>Agregación Secuencial:</strong> El sistema itera a través de cada grupo de clúster. Para cada grupo, invoca el <code>ClusterAggregator</code>.</li>
            <li><strong>Invocación y Cálculo del Agregador:</strong> Se llama al método <code>aggregate_cluster</code> del agregador, recibiendo la lista de objetos <code>AreaScore</code> que pertenecen a ese clúster. Aplica un cálculo ponderado final, según se define en el <code>AggregationSettings</code>, para consolidar las puntuaciones de área en una única puntuación de clúster estratégica.</li>
            <li><strong>Instanciación de ClusterScore:</strong> El resultado se encapsula en un objeto <code>ClusterScore</code>, que almacena la puntuación final y una lista de las puntuaciones de área contribuyentes.</li>
            <li><strong>Recolección de Resultados:</strong> El orquestador recolecta los objetos <code>ClusterScore</code> creados en el bucle. Esta lista final y pequeña de puntuaciones de alto nivel es la salida de la Fase 6 y la entrada directa para la evaluación macro final en la Fase 7.</li>
        </ol>

        <h2>4. Diagrama de Sistema: Consolidación Estratégica Final</h2>
        <div class="diagram-container">
            <svg width="100%" viewBox="0 0 900 600" xmlns="http://www.w3.org/2000/svg" font-family="JetBrains Mono, monospace" font-size="12px">
                <defs>
                    <linearGradient id="grad-blue" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#00D4FF"/><stop offset="100%" stop-color="#04101A"/></linearGradient>
                    <linearGradient id="grad-green" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#39FF14"/><stop offset="100%" stop-color="#0B231B"/></linearGradient>
                    <marker id="arrow-copper" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#B2642E"/></marker>
                </defs>
                <style>
                    .box { stroke-width: 1.5; rx: 4px; }
                    .box-blue { fill: url(#grad-blue); stroke: #00D4FF; }
                    .box-green { fill: url(#grad-green); stroke: #39FF14; }
                    .label { fill: #E5E7EB; text-anchor: middle; }
                    .sub-label { fill: #E5E7EB; opacity: 0.7; font-size: 9px; text-anchor: middle; }
                    .flow-line { stroke: #B2642E; stroke-width: 1.5; marker-end: url(#arrow-copper); }
                </style>

                <rect x="350" y="20" width="200" height="50" class="box box-green"/>
                <text x="450" y="50" class="label">Entrada: Lista de 10 AreaScores</text>

                <path class="flow-line" d="M450 70 V 110"/>

                <rect x="350" y="110" width="200" height="60" class="box box-blue"/>
                <text x="450" y="140" class="label">Enriquecimiento y Agrupación</text>
                <text x="450" y="155" class="sub-label">Clave: cluster_id del Monolito</text>

                <path class="flow-line" d="M450 170 V 210"/>

                <!-- Groups -->
                <g id="groups">
                    <rect x="50" y="210" width="200" height="60" fill="rgba(0,212,255,0.1)" stroke="#00D4FF" stroke-dasharray="2,2"/>
                    <text x="150" y="240" class="label">Clúster A: "Derechos Humanos"</text>
                    <text x="150" y="255" class="sub-label">PA01, PA04, PA05, PA08</text>

                    <rect x="350" y="210" width="200" height="60" fill="rgba(0,212,255,0.1)" stroke="#00D4FF" stroke-dasharray="2,2"/>
                    <text x="450" y="240" class="label">Clúster B: "Gobernanza"</text>
                    <text x="450" y="255" class="sub-label">PA02, PA07, PA09</text>

                    <rect x="650" y="210" width="200" height="60" fill="rgba(0,212,255,0.1)" stroke="#00D4FF" stroke-dasharray="2,2"/>
                    <text x="750" y="240" class="label">Clúster C: "Desarrollo"</text>
                    <text x="750" y="255" class="sub-label">PA03, PA06, PA10</text>
                </g>

                <path class="flow-line" d="M150 270 V 310"/>
                <path class="flow-line" d="M450 270 V 310"/>
                <path class="flow-line" d="M750 270 V 310"/>

                <!-- Aggregation Logic -->
                <g id="aggregation">
                    <rect x="75" y="310" width="150" height="50" class="box box-blue"/>
                    <text x="150" y="340" class="label">ClusterAggregator</text>
                    <rect x="375" y="310" width="150" height="50" class="box box-blue"/>
                    <text x="450" y="340" class="label">ClusterAggregator</text>
                    <rect x="675" y="310" width="150" height="50" class="box box-blue"/>
                    <text x="750" y="340" class="label">ClusterAggregator</text>
                </g>

                <path class="flow-line" d="M150 360 V 400"/>
                <path class="flow-line" d="M450 360 V 400"/>
                <path class="flow-line" d="M750 360 V 400"/>

                <!-- Aggregated Results -->
                <g id="results">
                    <rect x="75" y="400" width="150" height="50" class="box box-green"/>
                    <text x="150" y="430" class="label">ClusterScore A</text>
                    <rect x="375" y="400" width="150" height="50" class="box box-green"/>
                    <text x="450" y="430" class="label">ClusterScore B</text>
                    <rect x="675" y="400" width="150" height="50" class="box box-green"/>
                    <text x="750" y="430" class="label">ClusterScore C</text>
                </g>

                <path class="flow-line" d="M150 450 v 40 H 450"/>
                <path class="flow-line" d="M450 450 v 40"/>
                <path class="flow-line" d="M750 450 v 40 H 450"/>

                <path class="flow-line" d="M450 490 V 520"/>

                <rect x="325" y="520" width="250" height="50" class="box box-green"/>
                <text x="450" y="550" class="label">Salida: Lista de ~4 ClusterScores</text>
            </svg>
        </div>

        <h2>5. Pseudocódigo Ilustrativo</h2>
        <pre><code>
FUNCIÓN _aggregate_clusters(puntuaciones_area, config):
    // Paso 1: Construir un mapa de ID de área de política a ID de clúster desde el monolito
    mapa_area_a_cluster = PARSEAR_DEFINICIONES_CLUSTER(config.monolith)

    puntuaciones_enriquecidas = []
    PARA puntuacion EN puntuaciones_area:
        cluster_id = mapa_area_a_cluster.get(puntuacion.area_id)
        si cluster_id:
            puntuacion.cluster_id = cluster_id
            puntuaciones_enriquecidas.APILAR(puntuacion)

    // Paso 2: Agrupar las 10 puntuaciones de área enriquecidas por cluster_id
    puntuaciones_agrupadas = AGRUPAR_POR(puntuaciones_enriquecidas, clave="cluster_id")

    // Paso 3-6: Procesar secuencialmente cada grupo de clúster
    puntuaciones_cluster = []
    agregador = nuevo ClusterAggregator(config.aggregation_settings)
    PARA cluster_id, items EN puntuaciones_agrupadas.items():
        puntuacion_agregada = agregador.aggregate_cluster(items)

        puntuacion_cluster = nuevo ClusterScore(
            cluster_id = cluster_id,
            score = puntuacion_agregada,
            contributing_areas = items
        )
        puntuaciones_cluster.APILAR(puntuacion_cluster)

    RETORNAR puntuaciones_cluster
        </code></pre>

        <h2>6. Lista de Verificación Operacional para Auditoría</h2>
        <ul>
            <li><strong>Verificar Recuento de Entrada:</strong> Confirmar que la entrada es una lista de exactamente 10 objetos <code>AreaScore</code>.</li>
            <li><strong>Verificar Recuento de Salida:</strong> Afirmar que la salida final es una lista que contiene un número pequeño de objetos <code>ClusterScore</code> (ej., 3-5), coincidiendo con el número de clústeres definidos en el monolito.</li>
            <li><strong>Auditar Mapeo de Clúster:</strong> Comprobar las definiciones de clúster del monolito y verificar que los objetos <code>AreaScore</code> han sido agrupados correctamente bajo sus clústeres padres.</li>
            <li><strong>Comprobar Pérdida de Datos:</strong> Asegurar que todos los 10 objetos <code>AreaScore</code> de entrada (siempre que todos estén mapeados a un clúster) están presentes dentro de las listas `contributing_areas` de los objetos <code>ClusterScore</code> de salida.</li>
            <li><strong>Verificar Trazabilidad:</strong> Seleccionar un <code>ClusterScore</code> de salida y confirmar que todas sus `contributing_areas` están alineadas temáticamente con el propósito estratégico del clúster, según se describe en la documentación conceptual del proyecto.</li>
        </ul>
    </div>
</body>
</html>
