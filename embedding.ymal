# =============================================================================
# POLICY EMBEDDING CONFIG — Definición rigurosa y lista para executors
# Instanciación: PolicyEmbeddingConfig()
# =============================================================================
policy_embedding:

  # -------------------------
  # 1) PARÁMETROS (valores por defecto)
  # -------------------------
  params:
    embedding_model: "MODEL_PARAPHRASE_MULTILINGUAL"   # str
    cross_encoder_model: "DEFAULT_CROSS_ENCODER_MODEL" # str
    chunk_size: 512                                    # int
    chunk_overlap: 128                                 # int
    top_k_candidates: 50                               # int
    top_k_rerank: 10                                   # int
    mmr_lambda: 0.7                                    # float
    prior_strength: 1.0                                # float
    batch_size: 32                                     # int
    normalize_embeddings: true                         # bool

  # -------------------------
  # 2) ESPACIOS Y DOMINIOS (conjuntos)
  # -------------------------
  sets:
    # Modelos: símbolos abstractos mapeados por executors a implementaciones reales
    M_embed: "{MODEL_PARAPHRASE_MULTILINGUAL}"         # ⊆ Σ* (cadenas válidas del registro de modelos)
    M_cross: "{DEFAULT_CROSS_ENCODER_MODEL}"           # ⊆ Σ*
    N_plus:  "ℕ⁺"                                      # {1,2,3,...}
    B:       "{true, false}"
    I01:     "[0,1]"                                   # intervalo real cerrado

  # -------------------------
  # 3) TIPADO (función de pertenencia)
  # -------------------------
  typing:
    embedding_model   ∈ M_embed
    cross_encoder_model ∈ M_cross
    chunk_size        ∈ N_plus
    chunk_overlap     ∈ N_plus ∪ {0}
    top_k_candidates  ∈ N_plus
    top_k_rerank      ∈ N_plus ∪ {0}
    mmr_lambda        ∈ I01
    prior_strength    ∈ ℝ, prior_strength > 0
    batch_size        ∈ N_plus
    normalize_embeddings ∈ B

  # -------------------------
  # 4) INVARIANTES (restricciones duras)
  # -------------------------
  invariants:
    - name: overlap_lt_size
      expr: "0 ≤ chunk_overlap < chunk_size"
      fail_action: "raise ValueError('chunk_overlap must be < chunk_size')"
    - name: rerank_bound
      expr: "0 ≤ top_k_rerank ≤ top_k_candidates"
      fail_action: "coerce top_k_rerank := top_k_candidates"
    - name: mmr_closed_interval
      expr: "0 ≤ mmr_lambda ≤ 1"
      fail_action: "clip to nearest bound"
    - name: positive_batch
      expr: "batch_size ≥ 1"
      fail_action: "raise ValueError('batch_size must be ≥ 1')"
    - name: prior_positive
      expr: "prior_strength > 0"
      fail_action: "raise ValueError('prior_strength must be > 0')"

  # -------------------------
  # 5) CONSISTENCIAS DERIVADAS (no-harder-than defaults)
  # -------------------------
  derived_consistency:
    # Conjunto de candidatos que pasan a re-rank es un subconjunto finito:
    - "∀ Q ⊆ D (|Q| = top_k_candidates) ⇒ R ⊆ Q ∧ |R| = top_k_rerank"
    # Cobertura de chunks forma partición con solapamiento controlado:
    - "Dados textos T y ventana w=chunk_size, o=chunk_overlap,
       la familia de índices { [i, i+w) } con paso (w-o) es una cobertura de T
       y satisface intersecciones |[i, i+w) ∩ [i+(w-o), i+2w-o)| = o."
    # Normalización convierte cada embedding en un punto de la esfera unitaria:
    - "normalize_embeddings=true ⇒ ∀ v ≠ 0,  v̂ := v/‖v‖₂  con  ‖v̂‖₂ = 1"

  # -------------------------
  # 6) POLÍTICA DE COERCIÓN (máximo rendimiento sin romper contratos)
  # -------------------------
  coercion_policy:
    # Coacciones son idempotentes y no alteran semántica buscada.
    on_violation:
      top_k_rerank: "min(top_k_rerank, top_k_candidates)"
      mmr_lambda:   "clip(mmr_lambda, 0, 1)"
      others:       "raise (explícito; no silenciar errores estructurales)"

  # -------------------------
  # 7) CONTRATO PARA EXECUTORS (interfaz mínima y orden de uso)
  # -------------------------
  executors_contract:
    expects_dataclass: "PolicyEmbeddingConfig"
    instantiation: "cfg = PolicyEmbeddingConfig()"  # sin argumentos → defaults arriba
    usage_order:
      - "segment(text, chunk_size, chunk_overlap)"
      - "embeddings := E_model(segments, batch_size, normalize_embeddings)"
      - "candidates := ANN.top_k(embeddings, k=top_k_candidates)"
      - "reranked := CrossEncoder.rank(candidates, model=cross_encoder_model, k=top_k_rerank)"
      - "mmr := MMR.select(reranked, lambda=mmr_lambda)"
      - "apply_prior(prior_strength)  # ponderación externa; no modifica cfg"
    time_complexity_note: "chunking O(n); ANN ≈ O(log n) por consulta; cross-encoder O(k); MMR O(k²) acotado por top_k_rerank"

  # -------------------------
  # 8) AUDITORÍA LOCAL (pre-flight checks)
  # -------------------------
  audit:
    check_list:
      - "embedding_model ∈ registry"
      - "cross_encoder_model ∈ registry"
      - "0 ≤ chunk_overlap < chunk_size"
      - "top_k_rerank ≤ top_k_candidates"
      - "0 ≤ mmr_lambda ≤ 1"
      - "prior_strength > 0"
      - "batch_size ≥ 1"
    result: "pass_if_all_true"

  # -------------------------
  # 9) EJEMPLOS CANÓNICOS (IDEMPOTENTES)
  # -------------------------
  canonical_examples:
    default_instance:
      python: "cfg = PolicyEmbeddingConfig()"
      asserts:
        - "cfg.embedding_model == 'MODEL_PARAPHRASE_MULTILINGUAL'"
        - "cfg.cross_encoder_model == 'DEFAULT_CROSS_ENCODER_MODEL'"
        - "cfg.chunk_size == 512 and cfg.chunk_overlap == 128"
        - "cfg.top_k_candidates == 50 and cfg.top_k_rerank == 10"
        - "cfg.mmr_lambda == 0.7 and cfg.prior_strength == 1.0"
        - "cfg.batch_size == 32 and cfg.normalize_embeddings is True"
    safe_coercion:
      given: { top_k_candidates: 20, top_k_rerank: 25 }
      coerced: { top_k_rerank: 20 }
      reason: "rerank_bound invariant"
