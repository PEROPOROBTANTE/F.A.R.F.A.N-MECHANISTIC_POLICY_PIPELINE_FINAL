# PATCH FILE for executors.py
# Apply these changes to integrate ExecutorConfig WITHOUT creating new layers

# LINE ~50: Add import
from .executor_config import ExecutorConfig, CONSERVATIVE_CONFIG

# LINE ~2000: Fix AdvancedDataFlowExecutor
class AdvancedDataFlowExecutor(ABC):
    """Base advanced executor with configuration support."""
    
    def __init__(
        self, 
        method_executor, 
        signal_registry=None,
        config: ExecutorConfig | None = None
    ) -> None:
        self.executor = method_executor
        self.signal_registry = signal_registry
        self.config = config or CONSERVATIVE_CONFIG
        
        # Validate config is not None after fallback
        if self.config is None:
            raise RuntimeError("ExecutorConfig is required and cannot be None")
        
        logger.info(
            "executor_initialized",
            extra={
                "executor_class": self.__class__.__name__,
                "config_hash": self.config.compute_hash(),
                "timeout_s": self.config.timeout_s,
                "retry": self.config.retry,
            }
        )

# LINE ~2150: Fix execute_with_optimization to use config
def execute_with_optimization(
    self,
    doc: Any,
    method_executor: Any,
) -> dict[str, Any]:
    """Execute with config-driven parameters."""
    
    # LINE ~2280: Use config retry instead of hardcoded
    max_retries = self.config.retry  # Was: max_retries = 3
    
    # Add timeout enforcement
    import signal as signal_module
    import functools
    
    def timeout_handler(signum, frame):
        raise TimeoutError(f"Method execution exceeded {self.config.timeout_s}s")
    
    # Set alarm for timeout
    signal_module.signal(signal_module.SIGALRM, timeout_handler)
    signal_module.alarm(int(self.config.timeout_s))
    
    try:
        for attempt in range(max_retries):
            try:
                # ... existing execution code ...
                pass
            except Exception as e:
                if attempt < max_retries - 1:
                    logger.warning(f"Attempt {attempt + 1} failed: {e}")
                    continue
                raise
    finally:
        signal_module.alarm(0)  # Cancel alarm

# Update ALL 30 executor constructors (D1Q1 through D6Q5)
# Example for D1Q1_Executor (apply to all):
class D1Q1_Executor(AdvancedDataFlowExecutor):
    def __init__(
        self, 
        method_executor, 
        signal_registry=None,
        config: ExecutorConfig | None = None
    ) -> None:
        super().__init__(method_executor, signal_registry, config)